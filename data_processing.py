import datetime
from datetime import timedelta
import re


def combine_subs_into_sentences(srt_data: list) -> list:
    """Combines subtitles when they end before end of sentence mark is reached.

    :param srt_data: subtitle information, list containing dicts with the keys: start, end, content
    :return: concat subtitles by punctuation marks, same format as srt_data
    """
    subs = [sub['content'] for sub in srt_data]
    new_srt_data = []
    full_sentences = []
    current_sentence = []
    start_time = srt_data[0]['start']

    for i, subsentence in enumerate(subs):
        current_sentence.append(subsentence.strip())
        # check if sentence ends
        if subsentence[-1] in '.!?':
            # join the subsentences
            full_sentences.append(' '.join(current_sentence))
            new_srt_data.append({'start': start_time,
                                 'end': srt_data[i]['end'],
                                 'content': ' '.join(current_sentence)})
            current_sentence = []
            if i + 1 < len(subs):
                start_time = srt_data[i + 1]['start']

    # add leftover subsentences
    if current_sentence:
        full_sentences.append(' '.join(current_sentence))
        new_srt_data.append({'start': start_time,
                             'end': srt_data[-1]['end'],
                             'content': ' '.join(current_sentence)})

    return new_srt_data


def concat_by_pauses(srt_data: list, pause_length: int = 4) -> list:
    """Concatenate the subtitle sequences into scenes.

    :param pause_length: in seconds, time between two consecutive subtitle sequences
    :param srt_data: subtitle information, list containing dicts with the keys: start, end, content
    :return: contains subtitles concatenated into scenes, same format as srt_data
    """
    subs = [sub['content'] for sub in srt_data]
    new_srt_data = []
    full_sentences = []
    current_sentence = []
    start_time = srt_data[0]['start']
    pauses = []

    # calculate pauses
    for i, subsentence in enumerate(subs):
        current_sentence.append(subsentence.strip())
        # test if pause between two consecutive (current and next) subs is >= pause_length
        if i + 1 < len(subs):
            pause = srt_data[i + 1]['start'] - srt_data[i]['end']
        else:
            pause = timedelta(seconds=pause_length + 1)
        pauses.append(pause)
        if pause >= timedelta(seconds=pause_length):
            full_sentences.append(' '.join(current_sentence))
            # join the subsentences
            full_sentences.append(' '.join(current_sentence))
            new_srt_data.append({'start': start_time,
                                 'end': srt_data[i]['end'],
                                 'content': ' '.join(current_sentence)})
            current_sentence = []
            if i + 1 < len(subs):
                start_time = srt_data[i + 1]['start']

    # add leftover subsentences
    if current_sentence:
        full_sentences.append(' '.join(current_sentence))
        new_srt_data.append({'start': start_time,
                             'end': srt_data[-1]['end'],
                             'content': ' '.join(current_sentence)})

    return new_srt_data


def format_timedelta(td: datetime.timedelta) -> str:
    """Format timedelta into a nice readable string.

    :param td: datetime.timedelta
    :return: string, formatted timedelta -> HH:MM:SS,fff
    """
    # format timedelta into a more readable string output of the form 00:00:00:000 (same as in .srt)
    total_milliseconds = int(td.total_seconds() * 1000)

    hours, remainder = divmod(total_milliseconds, 3600000)
    minutes, remainder = divmod(remainder, 60000)
    seconds, milliseconds = divmod(remainder, 1000)

    return f"{hours:02}:{minutes:02}:{seconds:02},{milliseconds:03}"


def extract_model_response(text: str) -> str:
    """Removes the thinking process output from the model response.
    (since deepseek-r1 is used as model)

    :param text: full model response
    :return: model response without thinking process
    """
    # removes everything within <think>...</think> to only return the model response without the thinking process
    return re.sub(r"<think>.*?</think>\s*", "", text, flags=re.DOTALL)


def extract_mood(text: str) -> str:
    """Extracts the mood from a string.
    Uses one of the predefined moods (which can be generated by the model).

    :param text: string probably containing mood
    :return: string, mood as one word
    """
    # check which mood is contained in the string and return that one
    moods = ["Melancholic", "Romantic", "Tense", "Mysterious", "Humorous",
             "Cheerful", "Exciting", "Dark", "Hopeful", "Contemplative"]

    for mood in moods:
        if mood.lower() in text.lower():
            return mood
    return ""


def str_fmt_list(text: str) -> list:
    """Extracts a list from the text and converts it into a python list

    :param text: string that represent or contain a list
    :return: list of strings
    """
    # takes as input a  and returns a
    text = text.replace('"', '')
    text = text.replace("'", '')
    list_content = re.sub(r".*\[", "", text, flags=re.DOTALL)
    list_content = re.sub(r"].*", "", list_content, flags=re.DOTALL)
    list_out = [s.lstrip(' ') for s in list_content.split(',')]
    if 'None' in list_out:
        return []
    return list_out
